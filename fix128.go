package fixedPoint

// This file implements most of the fixed-point arithmetic operations for 128-bit
// fixed-point types. It is generated by generators/gen128.py by replacing 64-bit
// operations with their 128-bit counterparts using fix64.go as a template. If there
// are bugs in this file, they should be fixed in the fix64.go, and then this
// file should be regenerated with gen128.py. And, of course, if there are bugs in
// the fix64.go file, they should be fixed there first, and then this file should
// be regenerated.

func NewFix128(hi, lo uint64) Fix128 {
	return Fix128{
		Hi: raw64(hi),
		Lo: raw64(lo),
	}
}

// == Comparison Operators ==

// Eq returns true if a and b are equal.
func (a UFix128) Eq(b UFix128) bool { return isEqual128(raw128(a), raw128(b)) }
func (a Fix128) Eq(b Fix128) bool   { return isEqual128(raw128(a), raw128(b)) }

// Lt returns true if a is less than b.
func (a UFix128) Lt(b UFix128) bool { return ult128(raw128(a), raw128(b)) }
func (a Fix128) Lt(b Fix128) bool   { return slt128(raw128(a), raw128(b)) }

// Gt returns true if a is greater than b.
func (a UFix128) Gt(b UFix128) bool { return b.Lt(a) }
func (a Fix128) Gt(b Fix128) bool   { return b.Lt(a) }

// Lte returns true if a is less than or equal to b.
func (a UFix128) Lte(b UFix128) bool { return !a.Gt(b) }
func (a Fix128) Lte(b Fix128) bool   { return !a.Gt(b) }

// Gte returns true if a is greater than or equal to b.
func (a UFix128) Gte(b UFix128) bool { return !a.Lt(b) }
func (a Fix128) Gte(b Fix128) bool   { return !a.Lt(b) }

// IsNeg returns true if a is negative.
func (a Fix128) IsNeg() bool { return isNeg128(raw128(a)) }

// Neg returns the additive inverse of a (i.e. -a), or a negative overflow error
func (a Fix128) Neg() (Fix128, error) {
	if a == Fix128Min {
		// Special case: negating the minimum value will overflow.
		return Fix128Zero, ErrNegOverflow
	}

	return Fix128(neg128(raw128(a))), nil
}

// IsZero returns true if a is zero.
func (a UFix128) IsZero() bool { return isZero128(raw128(a)) }
func (a Fix128) IsZero() bool  { return isZero128(raw128(a)) }

// == Arithmetic Operators ==

// Add returns the sum of a and b, or an error on overflow.
func (a UFix128) Add(b UFix128) (UFix128, error) {
	sum, carry := add128(raw128(a), raw128(b), 0)

	if carry != 0 {
		return UFix128Zero, ErrOverflow
	}

	return UFix128(sum), nil
}

// Add returns the sum of a and b, or an error on overflow or negative overflow.
func (a Fix128) Add(b Fix128) (Fix128, error) {
	sum, _ := add128(raw128(a), raw128(b), 0)

	res := Fix128(sum)

	// Check for overflow by checking the sign bits of the operands and the result.
	if !a.IsNeg() && !b.IsNeg() && res.IsNeg() {
		return Fix128Zero, ErrOverflow
	} else if a.IsNeg() && b.IsNeg() && !res.IsNeg() {
		return Fix128Zero, ErrNegOverflow
	}

	return res, nil
}

// Sub returns the difference of a and b, or an error on negative overflow.
func (a UFix128) Sub(b UFix128) (UFix128, error) {
	diff, borrow := sub128(raw128(a), raw128(b), 0)

	if borrow != 0 {
		return UFix128Zero, ErrNegOverflow
	}

	return UFix128(diff), nil
}

// Sub returns the difference of a and b, or an error on overflow or negative overflow.
func (a Fix128) Sub(b Fix128) (Fix128, error) {
	diff, _ := sub128(raw128(a), raw128(b), 0)

	res := Fix128(diff)

	// Overflow occurs when:
	// 1. Subtracting a positive from a non-positive results in a positive
	// 2. Subtracting a negative from a non-negative results in a negative
	// Subtracting two, non-zero values with the same sign can't overflow in a signed int64
	if !a.IsNeg() && b.IsNeg() && res.IsNeg() {
		return Fix128Zero, ErrOverflow
	} else if a.IsNeg() && !b.IsNeg() && !res.IsNeg() {
		return Fix128Zero, ErrNegOverflow
	}

	return res, nil
}

// Abs returns the absolute value of a as an unsigned value, with a sign value as an int64.
// Note that this method works properly for Fix128Min, which can NOT be represented as a positive Fix128.
func (a Fix128) Abs() (UFix128, int64) {
	if a.IsNeg() {
		// Neg of a raw type equal to "min value" (0x80000...) is a no-op!
		// And, the correct UNSIGNED value of the absolute value of min value is 0x80000...
		return UFix128(neg128(raw128(a))), -1
	}

	return UFix128(a), 1
}

// ApplySign converts a UFix128 to a Fix128, applying the sign specified by the input.
func (a UFix128) ApplySign(sign int64) (Fix128, error) {
	if sign == 1 {
		if a.Gt(UFix128(Fix128Max)) {
			return Fix128Zero, ErrOverflow
		}
		return Fix128(a), nil
	} else {
		// Special case: if the result's sign should be negative and the converted
		// value is the minimum representable value, we can just return the minimum
		// value. We need to do this because the comparison against FixMax will fail
		// below, even thought would be a valid result.
		if isEqual128(raw128(a), raw128(Fix128Min)) {
			return Fix128Min, nil
		}
		if a.Gt(UFix128(Fix128Max)) {
			return Fix128Zero, ErrNegOverflow
		}

		return Fix128(neg128(raw128(a))), nil
	}
}

// Mul returns the product of a and b, or an error on overflow or underflow.
func (a UFix128) Mul(b UFix128) (UFix128, error) {
	// It might seem strange to implement multiplication in terms of fused multiply-divide,
	// but it turns out that a simple fixed-point multiplication needs to both
	// multiply and divide anyway. (Multiply the inputs, and then divide by the scale factor.)

	// Additionally, the logic for handling rounding is REALLY not trivial, so
	// having that in one location is a big win. In the end, the only real cost
	// is the overhead of an extra function call, which might be inlined anyway.
	return a.FMD(b, UFix128One)
}

// Mul returns the product of a and b, or an error on overflow or underflow.
func (a Fix128) Mul(b Fix128) (Fix128, error) {
	// Same rationale as above for UFix128.Mul, but even more critical because handling the
	// signs correctly is ALSO not trivial.
	return a.FMD(b, Fix128One)
}

// Div returns the quotient of a and b, or an error on division by zero, overflow, or underflow.
func (a UFix128) Div(b UFix128) (UFix128, error) {
	// Same rationale for using FMD as for UFix128.Mul
	return a.FMD(UFix128One, b)
}

// Div returns the quotient of a and b, or an error on division by zero, overflow, or underflow.
func (a Fix128) Div(b Fix128) (Fix128, error) {
	// Same rationale as above...
	return a.FMD(Fix128One, b)
}

// FMD returns a*b/c without intermediate rounding, or an error on division by zero, overflow, or underflow.
func (a UFix128) FMD(b, c UFix128) (UFix128, error) {
	// Must come before the check for a or b == 0 so we flag 0.0/0.0 as an error.
	if c.IsZero() {
		return UFix128Zero, ErrDivByZero
	}

	if a.IsZero() || b.IsZero() {
		return UFix128Zero, nil
	}

	hi, lo := mul128(raw128(a), raw128(b))

	// If the hi part is >= the divisor the result can't fit in 64 bits.
	if UFix128(hi).Gte(c) {
		return UFix128Zero, ErrOverflow
	}

	quo, rem := div128(hi, lo, raw128(c))

	if ushouldRound128(rem, raw128(c)) {
		var carry uint64
		quo, carry = add128(quo, raw128Zero, 1)

		// Make sure we don't "round up" to a value outside of the range of UFix128!
		if carry != 0 {
			return UFix128Zero, ErrOverflow
		}
	}

	// We can't get here if a == 0 or b == 0 because we checked that first. So,
	// a quotient of 0 means the result is too small to represent, i.e. underflow.
	// Note that we check this AFTER rounding.
	if isZero128(quo) {
		return UFix128Zero, ErrUnderflow
	}

	return UFix128(quo), nil
}

// FMD returns a*b/c without intermediate rounding, or an error on division by zero, overflow, or underflow.
func (a Fix128) FMD(b, c Fix128) (Fix128, error) {
	// Must come before the check for a or b == 0 so we flag 0.0/0.0 as an error.
	if c.IsZero() {
		return Fix128Zero, ErrDivByZero
	}

	if a.IsZero() || b.IsZero() {
		return Fix128Zero, nil
	}

	// Determine the sign of the result based on the signs of a, b, and c.
	sign := int64(1)

	aUnsigned, signMul := a.Abs()
	sign *= signMul
	bUnsigned, signMul := b.Abs()
	sign *= signMul
	cUnsigned, signMul := c.Abs()
	sign *= signMul

	// Compute the result using unsigned arithmetic.
	res, err := aUnsigned.FMD(bUnsigned, cUnsigned)

	if err != nil {
		return Fix128Zero, applySign(err, sign)
	}

	return res.ApplySign(sign)
}

// Returns the remainder of a divided by b, or an error on division by zero.
func (a UFix128) Mod(b UFix128) (UFix128, error) {
	if b.IsZero() {
		return UFix128Zero, ErrDivByZero
	}

	rem := mod128(raw128(a), raw128(b))

	return UFix128(rem), nil
}

// Returns the remainder of a divided by b, the result matches the sign of a (as per Go's %
// operator).
func (a Fix128) Mod(b Fix128) (Fix128, error) {
	if b.IsZero() {
		return Fix128Zero, ErrDivByZero
	}

	aUnsigned, aSign := a.Abs()
	bUnsigned, _ := b.Abs()

	rem, err := aUnsigned.Mod(bUnsigned)

	if err != nil {
		return Fix128Zero, err
	}

	return rem.ApplySign(aSign)
}

// Sqrt returns the square root of x using Newton-Rhaphson. Note that this
// method returns an error result for consistency with other methods,
// but can't actually ever fail...
func (x UFix128) Sqrt() (UFix128, error) {
	if x.IsZero() {
		return UFix128Zero, nil
	}

	// Count the number of leading zero bits in x, this is a cheap way of estimating
	// the order of magnitude of the input.
	n := leadingZeroBits128(raw128(x))

	// The loop below needs to start with some kind of estimate for the square root.
	// The closer it is to correct, the faster the loop will converge. We'll start
	// with a number that has a number of leading zero bits halfway between the number
	// of leading zero bits of x and the number of leading zero bits of the fixed-point
	// representation of 1. This will be of the same order of magnitude as the square
	// root, allowing our Newton-Raphson loop below to converge quickly.

	est := raw128(x)

	if n < Fix128OneLeadingZeros {
		// If the input has fewer leading zeros than FixOne, we'll start with an input
		// estimate that is shifted right by half the difference
		est = ushiftRight128(est, (Fix128OneLeadingZeros-n)/2)
	} else {
		// If the input has more leading zeros than FixOne, we shift left.
		est = shiftLeft128(est, (n-Fix128OneLeadingZeros)/2)
	}

	// The inner loop here will frequently divide the input by the current estimate,
	// so instead of using the Fix128.Div method, we expand the numerator once outside
	// the loop, and then directly call div128 in the loop.
	xHi, xLo := mul128(raw128(x), raw128(Fix128One))

	for {
		// This division can't fail: est is always a positive value somewhere between
		// x and 1, so it est will also be between x and 1.
		quo, rem := div128(xHi, xLo, est)

		if ushouldRound128(rem, est) {
			quo, _ = add128(quo, raw128Zero, 1)
		}

		// We take the difference using basic arithmetic, since we know that quo
		// and est are close to each other and far away from zero, so the difference
		// will never overflow or underflow a signed int (although it can be negative).
		diff, _ := sub128(quo, est, 0)

		// If the difference is zero, we've converged cleanly.
		if isZero128(diff) {
			break
		}

		// If the difference is ±iota, we know that the correct answer is either
		// quo or est, but we can't be sure which one is closer! The easiest way to
		// be sure is to just square the two values and see which one is closer to
		// the original input.
		if isIota128(diff) {
			// Diff is positive, so quo is larger than est, and quo^2 will be larger than x

			// Note that ignoring the hi part of this multiplication, and the borrow bit of
			// the subtraction are both effectively doing math modulo 2^64. Since we know that
			// the error is less than 2^64, we just ignore those potential "overflows" and
			// accept that the result will be correct modulo 2^64.
			_, estLo := mul128(est, est)
			estError, _ := sub128(xLo, estLo, 0)

			_, quoLo := mul128(quo, quo)
			quoError, _ := sub128(quoLo, xLo, 0)

			if ult128(quoError, estError) {
				// If quo has a lower error, use that instead of est.
				est = quo
			}
			break
		} else if isNegIota128(diff) {
			// Same logic as above, except diff is negative, so quo is smaller
			_, estLo := mul128(est, est)
			estError, _ := sub128(estLo, xLo, 0)

			_, quoLo := mul128(quo, quo)
			quoError, _ := sub128(xLo, quoLo, 0)

			if ult128(quoError, estError) {
				// If the estimate is further away, we can just use quo.
				est = quo
			}
			// If quo has a lower error, use that instead of est.
			break
		}

		diff = sshiftRight128(diff, 1)

		est, _ = add128(est, diff, 0)
	}

	return UFix128(est), nil
}

func (x UFix128) Ln() (Fix128, error) {
	// TODO: x192.ln() provides a ton of precision that we don't need, it
	// would be ideal if we could pass an error limit to it so it could
	// stop early when we don't need the full precision.
	res192, err := x.toFix192().ln()

	if err != nil {
		return Fix128Zero, err
	}

	res, err := res192.toFix128()

	// TODO: Should this catch underflow?
	if err == ErrUnderflow {
		// For ln underflows, we just return 0.
		return Fix128Zero, nil
	}

	return res, err
}

// Exp(x) returns e^x, or an error on overflow or underflow. Note that although the
// input is a Fix128, the output is a UFix128, since e^x is always positive.
func (x Fix128) Exp() (UFix128, error) {
	// If x is 0, return 1.
	if x.IsZero() {
		return UFix128One, nil
	}

	// We can quickly check to see if the input will overflow or underflow
	if x.Gt(maxLn128) {
		return UFix128Zero, ErrOverflow
	} else if x.Lt(minLn128) {
		return UFix128Zero, ErrUnderflow
	}

	// Use the fix192 implementation of Exp
	res192, err := x.toFix192().exp()

	if err != nil {
		return UFix128Zero, err
	}

	return res192.toUFix128()
}

func (a UFix128) Pow(b Fix128) (UFix128, error) {
	// We accept 0^0 as 1.
	if b.IsZero() {
		return UFix128One, nil
	}

	if a.IsZero() {
		if b.IsNeg() {
			// 0^negative is undefined, so we return an error.
			return UFix128Zero, ErrDivByZero // 0^negative is undefined
		} else {
			// 0^positive is 0.
			return UFix128Zero, nil
		}
	}

	if a.Eq(UFix128One) {
		// 1^b is always 1, so we can return it directly.
		return UFix128One, nil
	}

	// a^1 is just a, so we can return it directly.
	if b.Eq(Fix128One) {
		return a, nil
	}

	a192 := a.toFix192()
	b192 := b.toFix192()

	res192, err := a192.pow(b192)

	if err != nil {
		return UFix128Zero, err
	}

	return res192.toUFix128()
}

func trigResult128(res192 fix192, err error) (Fix128, error) {
	if err != nil {
		return Fix128Zero, err
	}

	res, err := res192.toFix128()

	if err == ErrUnderflow {
		// For trig underflows, we just return 0.
		return Fix128Zero, nil
	} else if err != nil {
		return Fix128Zero, err
	}

	return res, nil
}

func (x Fix128) Sin() (Fix128, error) {
	x192 := x.toFix192()
	res192, err := x192.sin()

	return trigResult128(res192, err)
}

func (x Fix128) Cos() (Fix128, error) {
	x192 := x.toFix192()
	res192, err := x192.cos()

	return trigResult128(res192, err)
}
