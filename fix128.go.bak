package fixedPoint

var (
	raw128Zero = raw128{0, 0}
)

// A raw128 value that represents the scale factor for UFix128 and Fix128 (1e24).
var fix128Scale = raw128{54210, 2003764205206896640}

func (a UFix128) IsZero() bool {
	return raw128(a).isZero()
}

func (a Fix128) IsZero() bool {
	return raw128(a).isZero()
}

func (a Fix128) isNeg() bool {
	return int64(a.Hi) < 0
}

func (a Fix128) Neg() (Fix128, error) {
	// Negating a Fix128 is equivalent to subtracting it from zero, and
	// will always succeed UNLESS the input value is the most negative value.
	if a.Hi == 0x8000000000000000 && a.Lo == 0 {
		return Fix128Zero, ErrOverflow
	}

	// This subtraction is guaranteed to succeed without overflow. We could theoretically do
	// some bitwise operations here, but sub128 should inline to just two instructions...
	res, _ := sub128(raw128Zero, raw128(a), 0)

	return Fix128(res), nil
}

func (a UFix128) Cmp(b UFix128) int {
	// Compare as unsigned values
	return ucmp128(raw128(a), raw128(b))
}

func (a Fix128) Cmp(b Fix128) int {
	// Compare as signed values
	return scmp128(raw128(a), raw128(b))
}

func (a Fix128) Abs() (Fix128, error) {
	// If the value is negative, negate it to get the absolute value.
	if int64(a.Hi) < 0 {
		return a.Neg()
	}

	return a, nil
}

func (a UFix64) ToUFix128() UFix128 {
	unscaled := UFix128{0, uint64(a)}

	// UFix64 uses a scale factor of 1e8, and UFix128 uses a scale factor of 1e24.
	// To covert, we just scale up by 1e16.
	return unscaled.intMul(10000000000000000)
}

func (a Fix64) ToFix128() Fix128 {
	unscaled := Fix128{Hi: 0, Lo: uint64(a)}

	if a < 0 {
		// Copy the sign bit to the high part
		unscaled.Hi = 0xffffffffffffffff
	}

	// Fix64 uses a scale factor of 1e8, and UFix128 uses a scale factor of 1e24.
	// To covert, we just scale up by 1e16.
	return unscaled.intMul(10000000000000000)
}

func (a UFix128) ToUFix64() (UFix64, error) {
	if a.isZero() {
		return 0, nil
	}

	// UFix128 uses a scale factor of 1e24, and UFix64 uses a scale factor of 1e8.
	// To convert, we just scale down by 1e16.
	q, r := div128(raw128Zero, raw128(a), raw128{0, 10000000000000000})

	if r.Lo >= (10000000000000000 / 2) {
		q = add128To64(q, 1)
	}

	if q.Hi != 0 {
		// If the high part is non-zero, it means the value is too large to fit in UFix64.
		return 0, ErrOverflow
	}

	if q.Lo == 0 {
		// We previously checked for zero input, so if the result after division is zero,
		// then we underflowed
		return 0, ErrUnderflow
	}

	return UFix64(q.Lo), nil
}

func (a Fix128) ToFix64() (Fix64, error) {
	// Fix128 uses a scale factor of 1e24, and Fix64 uses a scale factor of 1e8.
	q, r := div128(raw128Zero, raw128(a), raw128{0, 10000000000000000})

	// Round up if the remainder is at least half of the divisor.
	if r.Lo >= (10000000000000000 / 2) {
		q = add128To64(q, 1)
	}

	if q.Hi != 0 && q.Hi != 0xffffffffffffffff {
		// If the high part is non-zero, it means the value is too large to fit in Fix64.
		if q.Hi < 0 {
			return 0, ErrNegOverflow
		} else {
			return 0, ErrOverflow
		}
	}

	return Fix64(q.Lo), nil
}

func (a UFix128) Add(b UFix128) (UFix128, error) {
	rawSum, carry := add128(raw128(a), raw128(b), 0)

	if carry != 0 {
		return UFix128Zero, ErrOverflow
	}

	return UFix128(rawSum), nil
}

func (a Fix128) Add(b Fix128) (Fix128, error) {
	// Add as unsigned values
	sum, _ := add128(raw128(a), raw128(b), 0)

	// Check for overflow by checking the sign bits of the operands and the result.
	if int64(a.Hi) >= 0 && int64(b.Hi) >= 0 && int64(sum.Hi) < 0 {
		return Fix128Zero, ErrOverflow
	} else if int64(a.Hi) < 0 && int64(b.Hi) < 0 && int64(sum.Hi) >= 0 {
		return Fix128Zero, ErrNegOverflow
	}

	return Fix128(sum), nil
}

func (a UFix128) Sub(b UFix128) (UFix128, error) {
	rawDiff, borrow := sub128(raw128(a), raw128(b), 0)

	if borrow != 0 {
		return UFix128Zero, ErrNegOverflow
	}

	return UFix128(rawDiff), nil
}

func (a Fix128) Sub(b Fix128) (Fix128, error) {
	rawDiff, _ := sub128(raw128(a), raw128(b), 0)

	if int64(a.Hi) >= 0 && int64(b.Hi) < 0 && int64(rawDiff.Hi) < 0 {
		return Fix128Zero, ErrOverflow
	} else if int64(a.Hi) < 0 && int64(b.Hi) >= 0 && int64(rawDiff.Hi) >= 0 {
		return Fix128Zero, ErrNegOverflow
	}

	return Fix128(rawDiff), nil
}

func (a UFix128) Mul(b UFix128) (UFix128, error) {
	hi, lo := mul128(raw128(a), raw128(b))

	// If the high part of the result is larger than or equal to the scale factor,
	// it means the result will be too large to fit in UFix128 after scaling.
	if ucmp128(hi, fix128Scale) >= 0 {
		return UFix128Zero, ErrOverflow
	}

	// If the product is non-zero, but less than the scale factor, it means the result is
	// too small to represent as a UFix128.
	if hi.isZero() && !lo.isZero() && ucmp128(lo, fix128Scale) < 0 {
		return UFix128Zero, ErrUnderflow
	}

	quo, _ := div128(hi, lo, fix128Scale)

	return UFix128(quo), nil
}

// An internal function that returns the sign flip of a value of a Fix128 as a UFix128.
// This is used in our division and multiplication functions to ensure that we
// can still handle the most negative value of Fix128 (0x8000000000000000, 0)
// which is not representable as a positive value in Fix128.
func (a Fix128) negAndConvert() UFix128 {
	if a.Hi == 0x8000000000000000 && a.Lo == 0 {
		return UFix128(a)
	} else {
		// This subtraction is guaranteed to succeed without overflow. We could theoretically do
		// some bitwise operations here, but sub128 should inline to just two instructions...
		res, _ := sub128(raw128Zero, raw128(a), 0)
		return UFix128(res)
	}
}

func (a Fix128) Mul(b Fix128) (Fix128, error) {
	resultIsNeg := false

	var aU, bU UFix128

	if a.isNeg() {
		resultIsNeg = !resultIsNeg
		aU = a.negAndConvert()
	} else {
		aU = UFix128(a)
	}

	if b.isNeg() {
		resultIsNeg = !resultIsNeg
		bU = b.negAndConvert()
	} else {
		bU = UFix128(b)
	}

	// Call the unsigned multiplication function.
	prod, err := aU.Mul(bU)

	if err != nil {
		if err == ErrOverflow && resultIsNeg {
			return Fix128Zero, ErrNegOverflow
		} else {
			return Fix128Zero, err
		}
	}

	// Special case: if the result's sign should be negative and the product is 0x8000000000000000,
	// the result is valid and equal to math.MinInt64. (Note that 0x8000000000000000 is
	// LARGER than math.MaxInt64, so this requires special handling.)
	if resultIsNeg && prod.Hi == 0x8000000000000000 && prod.Lo == 0 {
		return Fix128{Hi: 0x8000000000000000, Lo: 0}, nil
	}

	if prod.Hi > 0x7FFFFFFFFFFFFFFF {
		// If the product is larger than the maximum value of Fix128, we return an overflow error.
		if resultIsNeg {
			return Fix128Zero, ErrNegOverflow
		} else {
			return Fix128Zero, ErrOverflow
		}
	}

	res := Fix128(prod)

	if resultIsNeg {
		// We inline the subtractin intsead of calling Neg() because we don't need to check for
		// overflow (we've alread done the checks above).
		temp, _ := sub128(raw128Zero, raw128(res), 0)
		res = Fix128(temp)
	}

	return res, err
}

func (a UFix128) Div(b UFix128) (UFix128, error) {
	if b.IsZero() {
		// Must come before the check for a == 0 so we flag 0.0/0.0 as an error.
		return UFix128Zero, ErrDivByZero
	}

	if a.IsZero() {
		return UFix128Zero, nil
	}

	// We can apply the scale factor BEFORE we divide
	//
	// We're starting with (a * scale) and (b * scale) and we want to end
	// up with (a / b) * scale. The concatended hi-lo values here are equivalent
	// to be equal to (a * scale * scale). When we divide by (b * scale) we'll
	// get our desired result.
	hi, lo := mul128(raw128(a), fix128Scale)

	// If the high part of the dividend is greater than the divisor, the
	// result won't fit into 64 bits.
	if ucmp128(hi, raw128(b)) >= 0 {
		return UFix128Zero, ErrOverflow
	}

	quo, _ := div128(hi, lo, raw128(b))

	// We can't get here if a == 0 because we checked that first. So,
	// a quotient of 0 means the result is too small to represent, i.e. underflow.
	if quo.isZero() {
		return UFix128Zero, ErrUnderflow
	}

	return UFix128(quo), nil
}

func (a Fix128) Div(b Fix128) (Fix128, error) {
	resultIsNeg := false

	var aU, bU UFix128

	if a.isNeg() {
		resultIsNeg = !resultIsNeg
		aU = a.negAndConvert()
	} else {
		aU = UFix128(a)
	}

	if b.isNeg() {
		resultIsNeg = !resultIsNeg
		bU = b.negAndConvert()
	} else {
		bU = UFix128(b)
	}

	// Call the unsigned division function.
	prod, err := aU.Div(bU)

	if err != nil {
		if err == ErrOverflow && resultIsNeg {
			return Fix128Zero, ErrNegOverflow
		} else {
			return Fix128Zero, err
		}
	}

	// Special case: if the result's sign should be negative and the product is 0x8000000000000000,
	// the result is valid and equal to math.MinInt64. (Note that 0x8000000000000000 is
	// LARGER than math.MaxInt64, so this requires special handling.)
	if resultIsNeg && prod.Hi == 0x8000000000000000 && prod.Lo == 0 {
		return Fix128{Hi: 0x8000000000000000, Lo: 0}, nil
	}

	if prod.Hi > 0x7FFFFFFFFFFFFFFF {
		// If the product is larger than the maximum value of Fix128, we return an overflow error.
		if resultIsNeg {
			return Fix128Zero, ErrNegOverflow
		} else {
			return Fix128Zero, ErrOverflow
		}
	}

	res := Fix128(prod)

	if resultIsNeg {
		// We inline the subtractin intsead of calling Neg() because we don't need to check for
		// overflow (we've alread done the checks above).
		temp, _ := sub128(raw128Zero, raw128(res), 0)
		res = Fix128(temp)
	}

	return res, err
}

// returns a*b/c without intermediate rounding.
func (a UFix128) FMD(b, c UFix128) (UFix128, error) {
	// Must come before the check for a or b == 0 so we flag 0.0/0.0 as an error.
	if c.isZero() {
		return UFix128Zero, ErrDivByZero
	}

	if a.isZero() || b.isZero() {
		return UFix128Zero, nil
	}

	hi, lo := mul128(raw128(a), raw128(b))

	// If the divsor isn't at least as big as the high part of the product,
	// the result won't fit into 128 bits.
	if ucmp128(hi, raw128(c)) >= 0 {
		return UFix128Zero, ErrOverflow
	}

	quo, rem := div128(hi, lo, raw128(c))

	// We want to round up if the remainder is at least half the divisor.
	// This isn't as simple as just checking if rem >= c/2, because dividing c by two
	// *loses precision*. A more accurate solution would be to multiply the
	// remainder by 2 and compare it to c, but that can overflow uint64 if the
	// remainder is large.
	//
	// However, we KNOW the remainder is less than c, and we know that c fits in 64 bits,
	// so if the remainder is so large that multiplying it by 2 would overflow,
	// then it must be at least half of c. So, we first check to see if it WOULD
	// overflow when doubled (in which case it is definitely larger than c/2),
	// and otherwise we can safely multiply it by 2 and compare it to c.
	if ucmp128(rem, raw128(UFix128Max)) > 0 || ucmp128(rem.shiftLeft(1), raw128(c)) >= 0 {
		// Make sure we don't "round up" to a value outside of the range of UFix64!
		if quo.Hi == 0xffffffffffffffff && quo.Lo == 0xffffffffffffffff {
			return UFix128Zero, ErrOverflow
		}

		quo = add128To64(quo, 1)
	}

	// We can't get here if a == 0 or b == 0 because we checked that first. So,
	// a quotient of 0 means the result is too small to represent, i.e. underflow.
	if quo.isZero() {
		return UFix128Zero, ErrUnderflow
	}

	return UFix128(quo), nil
}

func (a raw128) isZero() bool {
	return a.Hi == 0 && a.Lo == 0
}
