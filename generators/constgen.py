# constgen.py
# Generates Go constant definitions for transcendental values (pi, 2*pi, pi/2, 3*pi/2, ln(2), etc.)
# for Fix64, fix64_extra, Fix128, fix128_extra, etc.
# Uses Decimal and mpmath for high-precision computation.

from decimal import *
import mpmath
from utils import go_hex128

getcontext().prec = 50
mpmath.mp.dps = 50

# Fixed-point scales
Fix64Scale = Decimal('1e8')
Fix128Scale = Decimal('1e24')
fix64Epsilon = Decimal('1e-8')  # Smallest representable difference in Fix64
fix128Epsion = Decimal('1e-24')  # Smallest representable difference in Fix128

UFix64Max = Decimal(0xffffffffffffffff) / Fix64Scale
Fix64Max = Decimal(0x7fffffffffffffff) / Fix64Scale
Fix64Min = Decimal(-0x8000000000000000) / Fix64Scale

extraBits = 20
fix64ExtraScale = Fix64Scale * (1 << extraBits)
fix128ExtraScale = Fix128Scale * (1 << extraBits)

# Base constants
pi = Decimal(str(mpmath.pi)) # Pi to 50 decimal places!
ln2 = Decimal(2).ln() # Natural logarithm of 2

 # Largest input to exp() that doesn't overflow
maxLn64 = UFix64Max.ln().quantize(fix64Epsilon, rounding='ROUND_DOWN')
 # Smallest input to exp() that doesn't underflow
minLn64 = (fix64Epsilon / 2).ln().quantize(fix64Epsilon, rounding='ROUND_DOWN')


# This value is used in clampAngle(), the function that takes an arbitrary input
# angle and returns it in the range (-π, π). The first step of that function
# is to compute x % 2π, which is suprisingly difficult to do accurately.
#
# The constant below is equal to 2π * 2662294. Where did 2662294 come from?
# I wrote a script that checked EVERY multiple of 2π to find one that minimizes
# error past the 8th decimal place. In particualr, 2π * 2662294 is equal to
# 16727686.5441923699999993294. What this means is that this particular constant
# (as a Fix64) an approximation of a multiple of 2•π that with an error of just
# 6.71e-16, even though it only has 8 decimal places. Taking x (as a Fix64) modulo this
# value is very accuracte, and means the other techniques in clampAngle() have to
# account for less accumulated error.
#
# (If we're honest, it's going to be exceedingly rare that we ever have to deal with
# such large inputs outside of testing, but since this is so cheap, we might as well
# use it to get a better approximation of x % 2π.)
#
# FWIW- There might be other, larger multiples of 2π that are even more accurate; we use
# 2662294 because 2•π•2662294 is less than the maximum value of representable as a
# fix64_extra. Once we've done this modulo operation we can safely convert the result
# to fix64_extra without overflow.
fix64_TwoPiMultiple = pi * 2 * 2662294

# Same idea as above, but for the range of fix64_extra, surprisingly, we get
# 16 decimal places of accuracy with a multiplier of just 29.
#
# NOTE: This value is slightly HIGHER thant 2π, while the previous one is slightly
# LOWER. This is advantageous because that means any error introduced by these
# two approximations will be in opposite directions. They don't exactly "cancel out"
# but at least they don't *compound*.
fix64_extra_TwoPiMultiple = pi * 2 * 29

# A similar factor for ln(2) for UFix64.
ufix64_ln2Factor = Decimal(133036616393)
ufix64_ln2Multiple = ln2 * ufix64_ln2Factor

# sin(x) is functionally linear for all values <= this "iota" value in fix64_extra
# The first non-linear term of the Taylor series for sin(x) is x^3/6, so this is the
# largest value of x for which x^3/6 is too small to represent in fix64_extra.
fix64_extra_sinIota = (Decimal(6) / Decimal(fix64ExtraScale)) ** (Decimal(1) / Decimal(3))

# the correction term used in ln() and exp() that equals ln(2) multiplied by 1024
ln2_term = ln2 * 2**12

# Output Go code
def go_const(name, value, typ):
    is128 = False
    match typ:
        case 'int64' | 'uint64':
            scaledValue = value

        case 'Fix64' | 'UFix64':
            scaledValue = value * Fix64Scale

        case 'fix64_extra':
            scaledValue = value * fix64ExtraScale

        case 'Fix128' | 'UFix128':
            scaledValue = value * Fix128Scale
            is128 = True
        
        case 'raw128':
            scaledValue = value
            is128 = True
        
        case _:
            raise ValueError(f"Unknown type: {typ}")

    intValue = int(scaledValue.to_integral_value(rounding=ROUND_HALF_UP))

    if is128:
        decl = 'var'
        hexString = f"{{0x{(intValue >> 64):016x}, 0x{(intValue & 0xffffffffffffffff):016x}}}"
        if type != 'raw128':
            hexString = f"raw128{hexString}"

    else:
        decl = 'const'
        hexString = hex(intValue)

    return f"{decl} {name} = {typ}({hexString})"

def main():
    print("// Code generated by testgen/constgen.py; DO NOT EDIT.")
    print("package fixedPoint")
    print()
    print("// Exported scale constants")
    print(f"const Fix64Scale = {Fix64Scale}")
    print("const UFix64One = UFix64(1 * Fix64Scale) // 1 in fix64")
    print("const Fix64One = Fix64(1 * Fix64Scale) // 1 in fix64")
    print("const UFix64Max = UFix64(0xffffffffffffffff) // Max value for UFix64")
    print("const Fix64Max = Fix64(0x7fffffffffffffff) // Max value for Fix64")
    print("const Fix64Min = Fix64(-0x8000000000000000) // Min value for Fix64")
    print()
    print(f"const Fix128Scale = {Fix128Scale} // NOTE: Bigger than uint64! Mostly here as documentation...")
    print(go_const('Fix128One', Decimal(1), 'Fix128'))
    print()
    print("// Internal scale constants")
    print(f"const extraBits = {extraBits} // Number of extra bits for fix64_extra and fix128_extra")
    print(f"const fix64ExtraScale = Fix64Scale << extraBits // {fix64ExtraScale}")
    print(f"const fix128ExtraScale = {fix128ExtraScale} // NOTE: Bigger than uint64! Mostly here as documentation...")
    print()
    print("// Fix64 transcendental constants (see constgen.py for more information)")
    print(go_const('Fix64_Pi', pi, 'Fix64'))
    print(go_const('fix64_2Pi', pi * 2, 'Fix64'))
    print(go_const('fix64_PiOver2', pi / 2, 'Fix64'))
    print(go_const('fix64_3PiOver2', pi * 3 / 2, 'Fix64'))
    print(go_const('fix64_TwoPiShifted33', pi * 2 * (2 ** 33), 'Fix64'))
    print(go_const('fix64_TwoPiMultiple', fix64_TwoPiMultiple, 'Fix64'))
    print(go_const('ln2_fix64', ln2, 'Fix64'))
    print(go_const('ufix64_ln2Factor', ufix64_ln2Factor, 'uint64'))
    print(go_const('ufix64_ln2Multiple', ufix64_ln2Multiple, 'UFix64'))
    print()
    print("// Fix128 transcendental constants")
    print(go_const('Fix128_Pi', pi, 'Fix128'))
    print(go_const('fix128_2Pi', pi * 2, 'Fix128'))
    print(go_const('fix128_PiOver2', pi / 2, 'Fix128'))
    print(go_const('fix128_3PiOver2', pi * 3 / 2, 'Fix128'))
    # print(go_const128('fix128_TwoPiShifted44', fix128_TwoPiShifted44, 'raw128'))
    print()
    print("// fix64_extra constants")
    print(go_const('fix64_extra_One', Decimal(1), 'fix64_extra'))
    print(go_const('fix64_extra_Pi', pi, 'fix64_extra'))
    print(go_const('fix64_extra_2Pi', pi * 2, 'fix64_extra'))
    print(go_const('fix64_extra_PiOver2', pi / 2, 'fix64_extra'))
    print(go_const('fix64_extra_3PiOver2', pi * 3 / 2, 'fix64_extra'))
    print(go_const('fix64_extra_sinIota', fix64_extra_sinIota, 'fix64_extra'))
    print(go_const('fix64_extra_TwoPiMultiple', fix64_extra_TwoPiMultiple, 'fix64_extra'))
    print()
    print("// ln(2) * 1024 at fix64_extra precision, used in ln() and exp()")
    print(go_const('ln2_fix64_term', ln2_term, 'fix64_extra'))
    print()
    print("// Valid logarithm bounds for Fix64")
    print(go_const('maxLn64', maxLn64, 'Fix64'))
    print(go_const('minLn64', minLn64, 'Fix64'))

if __name__ == "__main__":
    main()
