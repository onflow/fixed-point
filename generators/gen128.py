#!/usr/bin/env python3
"""
search_replace.py: Reads from stdin, performs word-delimited search-and-replace for a list of term mappings, and replaces a specific multi-line comment block.

Usage:
    cat input.txt | python3 search_replace.py > output.txt

Edit the 'replacements' list to add more mappings.
"""
import sys
import re

# List of [from, to] pairs for replacement (word-delimited)
replacements = [
    [r"add64", "add128",],
    [r"div64", "div128",],
    [r"Fix64", "Fix128",],
    [r"ufix64HalfPiScaled", "ufix128HalfPiScaled",],
    [r"UFix64Iota", "UFix128Iota",],
    [r"fix64Ln2Scaled", "fix128Ln2Scaled",],
    [r"fix64LnMultiplier", "fix128LnMultiplier",],
    [r"fix64LnScale", "fix128LnScale",],
    [r"Fix64Max", "Fix128Max",],
    [r"Fix64Min", "Fix128Min",],
    [r"Fix64One", "Fix128One",],
    [r"Fix64OneLeadingZeros", "Fix128OneLeadingZeros",],
    [r"ufix64PiScaled", "ufix128PiScaled",],
    [r"Fix64Scale", "Fix128Scale",],
    [r"fix64SinIotaScaled", "fix128SinIotaScaled",],
    [r"ufix64ThreeHalfPiScaled", "ufix128ThreeHalfPiScaled",],
    [r"fix64TrigMultiplier", "fix128TrigMultiplier",],
    [r"fix64TrigScale", "fix128TrigScale",],
    [r"ufix64TwoPiScaled", "ufix128TwoPiScaled",],
    [r"Fix64Zero", "Fix128Zero",],
    [r"isEqual64", "isEqual128",],
    [r"isIota64", "isIota128",],
    [r"isNeg64", "isNeg128",],
    [r"isNegIota64", "isNegIota128",],
    [r"isZero64", "isZero128",],
    [r"leadingZeroBits64", "leadingZeroBits128",],
    [r"minLn64", "minLn128",],
    [r"maxLn64", "maxLn128",],
    [r"mul64", "mul128",],
    [r"neg64", "neg128",],
    [r"raw64", "raw128",],
    [r"raw64Zero", "raw128Zero",],
    [r"result192ToFix64", "result192ToFix128",],
    [r"shiftLeft64", "shiftLeft128",],
    [r"sintDiv64", "sintDiv128",],
    [r"sintMul64", "sintMul128",],
    [r"slt64", "slt128",],
    [r"sshiftRight64", "sshiftRight128",],
    [r"sub64", "sub128",],
    [r"toFix64", "toFix128",],
    [r"toUFix64", "toUFix128",],
    [r"trigResult64", "trigResult128",],
    [r"UFix64", "UFix128",],
    [r"UFix64One", "UFix128One",],
    [r"UFix64Zero", "UFix128Zero",],
    [r"uintDiv64", "uintDiv128",],
    [r"uintMul64", "uintMul128",],
    [r"ult64", "ult128",],
    [r"unscaledRaw64", "unscaledRaw128",],
    [r"ushiftRight64", "ushiftRight128",],
    [r"ushouldRound64", "ushouldRound128",],
    [r"clampAngle64", "clampAngle128",],
    [r"lnInnerLoop64", "lnInnerLoop128",],
    [r"innerSin64", "innerSin128",],
]

# Multi-line comment block replacement
START_LINE = r"// This file implements most of the fixed-point"
END_LINE = r"// If you see things in this file that seem awkward"
NEW_COMMENT = """
// This file implements most of the fixed-point arithmetic operations for 128-bit
// fixed-point types. It is generated by generators/gen128.py by replacing 64-bit
// operations with their 128-bit counterparts using fix64.go as a template. If there
// are bugs in this file, they should be fixed in the fix64.go, and then this
// file should be regenerated with gen128.py. And, of course, if there are bugs in
// the fix64.go file, they should be fixed there first, and then this file should
// be regenerated.
""".strip()

def replace_multiline_comment(text):
    lines = text.splitlines(keepends=True)
    start_idx = end_idx = None
    for i, line in enumerate(lines):
        if start_idx is None and line.lstrip().startswith(START_LINE):
            start_idx = i
        elif start_idx is not None and line.lstrip().startswith(END_LINE):
            end_idx = i
            break
    if start_idx is not None and end_idx is not None:
        # Check all lines in between start and end start with '//'
        if all(l.lstrip().startswith('//') for l in lines[start_idx:end_idx+1]):
            # Replace the block
            return ''.join(lines[:start_idx]) + NEW_COMMENT + '\n' + ''.join(lines[end_idx+1:])
    return text

def main():
    # Read all input from stdin
    text = sys.stdin.read()
    # Replace the multi-line comment block if present
    text = replace_multiline_comment(text)
    # Perform word-delimited replacements
    for from_word, to_word in replacements:
        # Use word boundaries and re.MULTILINE to match across lines
        pattern = re.compile(rf"(?<![A-Za-z0-9_]){re.escape(from_word)}(?![A-Za-z0-9_])")
        text = pattern.sub(to_word, text)
    sys.stdout.write(text)

if __name__ == "__main__":
    main()


