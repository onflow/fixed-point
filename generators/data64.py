# data64.py
# Defines test data for UFix64 and Fix64 types

from decimal import Decimal
import re
from pipe import Pipe

BaseData64 = [
    # Simple cases
    ("", "0"),
    ("", "1"),
    ("", "5"),

    # Common repeating decimals
    ("1/9", "0.11111111"),
    ("1/3", "0.33333333"),
    ("2/3", "0.66666666"),
    ("1/7", "0.14285714"),

    # The smallest non-zero values
    ("", "3e-8"),
    ("", "6e-8"),
    ("", "9e-8"),

    # Random cases
    ("", "123.45678901"),
    ("", "0.00012345"),
    ("", "98765.4321"),
    ("", "31415.9265"),
    ("", "1234567890.12345678"),

    # sqrt(MaxUFix64) and nearby values
    ("sqrt(MaxUFix64)", "429496.7296"),
    ("sqrt(MaxUFix64) - epsilon", "429496.72959998"),
    ("sqrt(MaxUFix64) + epsilon", "429496.72960002"),

    # sqrt(HalfMaxUFix64) and sqrt(MaxFix64) and nearby values
    ("sqrt(HalfMaxUFix64)", "303700.04999760"),
    ("sqrt(HalfMaxUFix64) - epsilon", "303700.04999758"),
    ("sqrt(HalfMaxUFix64) + epsilon", "303700.04999762"),

    # Near the limits
    ("", "Max"),
    ("", "Max - 1"),
    ("", "Max - 0.001"),
    ("", "HalfMax"),
    ("", "HalfMax + 1"),
    ("", "HalfMax - 1"),
    ("", "HalfMax + 0.001"),
    ("", "HalfMax - 0.001"),
]

ExtraData64 = [
    # The prime factors of UINT64_MAX are 3, 5, 17, 257, 641, 65537, and 6700417
    # The values below are different subsets of those numbers multipled together to
    # create values for which some pairs should multiply to exactly UFix64Max.
    ("", "3"),
    ("", "15"),
    ("", "4391.25228929"),
    ("", "27530.74036095"),
    ("", "65535"),
    ("", "6700417"),
    ("", "2814792.71743489"),
    ("", "42007935"),
    ("", "12297829382.47303441"),
    ("", "61489146912.36517205"),

    # MaxUFix64 divided by powers of ten
    ("MaxUFix64 / 10", "18446744073.70955161"),
    ("MaxUFix64 / 100", "1844674407.37095516"),
    ("MaxUFix64 / 1000", "184467440.73709552"),
    ("MaxUFix64 / 10000", "18446744.07370955"),
    ("MaxUFix64 / 100000", "1844674.40737096"),
    ("MaxUFix64 / 1000000", "184467.44073710"),
    ("MaxUFix64 / 10000000", "18446.74407370"),
    ("MaxUFix64 / 100000000", "1844.67440737"),
    ("MaxUFix64 / 1000000000", "184.46744074"),
    ("MaxUFix64 / 10000000000", "18.44674407"),
    ("MaxUFix64 / 100000000000", "1.84467441"),

    # MaxFix64 divided by powers of ten
    ("MaxFix64 / 1", "92233720368.54775807"),
    ("MaxFix64 / 10", "9223372036.85477581"),
    ("MaxFix64 / 100", "922337203.68547758"),
    ("MaxFix64 / 1000", "92233720.36854776"),
    ("MaxFix64 / 10000", "9223372.03685478"),
    ("MaxFix64 / 100000", "922337.20368548"),
    ("MaxFix64 / 1000000", "92233.72036855"),
    ("MaxFix64 / 10000000", "9223.37203685"),
    ("MaxFix64 / 100000000", "922.33720369"),
    ("MaxFix64 / 1000000000", "92.23372037"),
    ("MaxFix64 / 10000000000", "9.22337204"),

    # Powers of ten
    ("", "1e-7"),
    ("", "1e-6"),
    ("", "1e-4"),
    ("", "1e-2"),
    ("", "1e-1"),
    ("", "1e1"),
    ("", "1e2"),
    ("", "1e4"),
    ("", "1e6"),
    ("", "1e10"),
    ("", "1e11"),

    # Powers of 2
    ("2^-8", "0.00390625"),
    ("2^-7", "0.0078125"),
    ("2^-6", "0.015625"),
    ("2^-5", "0.03125"),
    ("2^-4", "0.0625"),
    ("2^-3", "0.125"),
    ("2^-2", "0.25"),
    ("2^-1", "0.5"),
    ("2^1", "2"),
    ("2^2", "4"),
    ("2^3", "8"),
    ("2^4", "16"),
    ("2^5", "32"),
    ("2^6", "64"),
    ("2^8", "256"),
    ("2^9", "512"),
    ("2^20", "1048576"),
    ("2^30", "1073741824"),
    ("2^37", "137438953472"),

    # Trigonometric values
    ("pi/6", "0.52359878"),
    ("pi/4", "0.78539816"),
    ("pi/3", "1.04719755"),
    ("pi/2", "1.57079633"),
    ("pi", "3.14159265"),
    ("3*pi/2", "4.71238898"),
    ("2*pi", "6.28318531"),
    ("3*pi/4", "2.35619449"),
    ("sqrt(2)", "1.41421356"),
    ("sqrt(2)/2", "0.70710678"),

    # Failed test cases (known to fail in the past)
    ("1.57069631", "1.57069631"),
    ("1.57079633", "1.57079633"),

    # Logarithmic values
    ("ln(2)", "0.69314718"),
    ("ln(10)", "2.30258509"),
    ("e", "2.71828183"),
    ("e^2", "7.38905610"),

    # Maximal powers of numbers near 1.0 that still
    # fit in UFix64
    ("", "2594073894.15878282"),
    ("", "1297036953.56457608"),
    ("", "864691306.69984049"),
    ("", "648518483.26747268"),
    ("", "1842068065.18489616"),
    ("", "1893150627.30608242"),
    ("", "921034027.98727787"),
    ("", "946575308.92016459"),
]

# Additional inputs used for single-argument methods
BonusData64 = [
    # Odd multiples of pi/2, used for testing sin/cos/tan
    ("3/2*pi",  "4.71238898"),
    ("5/2*pi",  "7.85398163"),
    ("7/2*pi",  "10.99557428"),
    ("9/2*pi",  "14.13716694"),
    ("11/2*pi", "17.27875959"),
    ("13/2*pi", "20.42035224"),
    ("15/2*pi", "23.56194490"),
    ("17/2*pi", "26.70353755"),
    ("19/2*pi", "29.84513020"),

    # VERY large multiples of pi/2, the largest possible in the space of Fix64
    ("58717810045/2*pi", "92233720336.12648336"),
    ("58717810047/2*pi", "92233720339.26807601"),
    ("58717810049/2*pi", "92233720342.40966867"),
    ("58717810051/2*pi", "92233720345.55126132"),
    ("58717810053/2*pi", "92233720348.69285397"),
    ("58717810055/2*pi", "92233720351.83444663"),
    ("58717810057/2*pi", "92233720354.97603928"),
    ("58717810059/2*pi", "92233720358.11763193"),
    ("58717810061/2*pi", "92233720361.25922459"),
    ("58717810063/2*pi", "92233720364.40081724"),

    # Values that are close to the boundaries of UFix64 for exp()
    ("25.1", "25.1"),
    ("25.2", "25.2"),
    ("25.3", "25.3"),
    ("25.4", "25.4"),
    ("25.5", "25.5"),
    ("25.6", "25.6"),
    ("25.7", "25.7"),
    ("25.8", "25.8"),
    ("25.9", "25.9"),

    ("18.5", "18.5"),
    ("18.6", "18.6"),
    ("18.7", "18.7"),
    ("18.8", "18.8"),
    ("18.9", "18.9"),
    ("19.0", "19.0"),
    ("19.1", "19.1"),

    # A bunch of test data that was generated in early stages of development,
    # which could still useful for testing but not used in the main test suite
    # to save time.
	("0.000123", "0.000123"),
	("0.000321", "0.000321"),
	("0.000456", "0.000456"),
	("0.000789", "0.000789"),
	("0.19999999", "0.19999999"),
	("0.2", "0.2"),
	("0.20000001", "0.20000001"),
	("0.98765432", "0.98765432"),
	("1.0000001", "1.0000001"),
	("1.00001", "1.00001"),
	("1.001", "1.001"),
	("1.01", "1.01"),
	("1.1", "1.1"),
	("1.23456789", "1.23456789"),
	("1.5", "1.5"),
	("2.0000001", "2.0000001"),
	("2.000001", "2.000001"),
	("2.0001", "2.0001"),
	("2.001", "2.001"),
	("2.01", "2.01"),
	("2.1", "2.1"),
	("6", "6"),
	("7", "7"),
	("7.5", "7.5"),
	("9", "9"),
	("10.0000001", "10.0000001"),
	("17", "17"),
	("100.0000001", "100.0000001"),
	("100.000001", "100.000001"),
	("100.00001", "100.00001"),
	("100.0001", "100.0001"),
	("100.001", "100.001"),
	("100.01", "100.01"),
	("100.1", "100.1"),
	("123.456", "123.456"),
	("255", "255"),
	("257", "257"),
	("456.789", "456.789"),
	("641", "641"),
	("789.012", "789.012"),
	("1000.00001", "1000.00001"),
	("4369", "4369"),
	("10000.0001", "10000.0001"),
	("12345.6789", "12345.6789"),
	("32767.5", "32767.5"),
	("65537", "65537"),
	("100000.001", "100000.001"),
	("303700.0499", "303700.0499"),
	("429496.7295", "429496.7295"),
	("494211", "494211"),
	("1000000.01", "1000000.01"),
	("3350208.5", "3350208.5"),
	("10000000.1", "10000000.1"),
	("21003967.5", "21003967.5"),
	("99999999", "99999999"),
	("100000001", "100000001"),
	("46116860184.27387913", "46116860184.27387913"),
	("46116860184.27388003", "46116860184.27388003"),
	("46116860184.27388903", "46116860184.27388903"),
	("46116860184.27397903", "46116860184.27397903"),
	("46116860184.27487903", "46116860184.27487903"),
	("46116860184.28387903", "46116860184.28387903"),
	("46116860184.37387903", "46116860184.37387903"),
	("80000000000", "80000000000"),
	("90000000000", "90000000000"),
	("92233720368.44775807", "92233720368.44775807"),
	("92233720368.53775807", "92233720368.53775807"),
	("92233720368.54675807", "92233720368.54675807"),
	("92233720368.54765807", "92233720368.54765807"),
	("92233720368.54774807", "92233720368.54774807"),
	("92233720368.54775707", "92233720368.54775707"),
	("92233720368.54775797", "92233720368.54775797"),
	("92233720368.54775817", "92233720368.54775817"),
	("92233720368.54775818", "92233720368.54775818"),
	("92233720368.54775907", "92233720368.54775907"),
	("92233720368.54775908", "92233720368.54775908"),
	("92233720368.54776807", "92233720368.54776807"),
	("92233720368.54776808", "92233720368.54776808"),
	("92233720368.54785807", "92233720368.54785807"),
	("92233720368.54785808", "92233720368.54785808"),
	("92233720368.54875807", "92233720368.54875807"),
	("92233720368.54875808", "92233720368.54875808"),
	("92233720368.55775807", "92233720368.55775807"),
	("92233720368.55775808", "92233720368.55775808"),
	("92233720368.64775807", "92233720368.64775807"),
	("92233720368.64775808", "92233720368.64775808"),
	("99999999999", "99999999999"),
	("138350580551.82163712", "138350580551.82163712"),
	("138350580552.72163712", "138350580552.72163712"),
	("138350580552.81163712", "138350580552.81163712"),
	("138350580552.82063712", "138350580552.82063712"),
	("138350580552.82153712", "138350580552.82153712"),
	("138350580552.82162712", "138350580552.82162712"),
	("138350580552.82163612", "138350580552.82163612"),
	("138350580552.82163702", "138350580552.82163702"),
	("138350580552.82163722", "138350580552.82163722"),
	("138350580552.82163812", "138350580552.82163812"),
	("138350580552.82164712", "138350580552.82164712"),
	("138350580552.82173712", "138350580552.82173712"),
	("138350580552.82263712", "138350580552.82263712"),
	("138350580552.83163712", "138350580552.83163712"),
	("138350580552.92163712", "138350580552.92163712"),
	("138350580553.82163712", "138350580553.82163712"),
	("184446436769.59551616", "184446436769.59551616"),
	("184464090528.59551616", "184464090528.59551616"),
	("184467137037.04561616", "184467137037.04561616"),
	("184467375200.09551616", "184467375200.09551616"),
	("184467407969.59551616", "184467407969.59551616"),
	("184467428391.41661616", "184467428391.41661616"),
	("184467440280.30651616", "184467440280.30651616"),
	("184467440728.09551616", "184467440728.09551616"),
	("184467440729.59551616", "184467440729.59551616"),
	("184467440730.09551616", "184467440730.09551616"),
	("184467440731.09551616", "184467440731.09551616"),
	("184467440735.59551616", "184467440735.59551616"),
	("184467440735.99551616", "184467440735.99551616"),
	("184467440736.08551616", "184467440736.08551616"),
	("184467440736.09451616", "184467440736.09451616"),
	("184467440736.09541616", "184467440736.09541616"),
	("184467440736.09550616", "184467440736.09550616"),
	("184467440736.09551516", "184467440736.09551516"),
	("184467440736.09551606", "184467440736.09551606"),
	("184467440736.10786184", "184467440736.10786184"),
	("184467440736.89551615", "184467440736.89551615"),
	("184467440736.89551616", "184467440736.89551616"),
	("184467440736.89551617", "184467440736.89551617"),
	("184467440737.09472716", "184467440737.09472716"),
	("184467440737.09551605", "184467440737.09551605"),
]

# Generates a sequence of UFix64 test values based on the provided raw values.
# Each test value is a tuple of (string representation, Decimal value).
@Pipe
def generateUFix64Values(raw_values):
    for (rawD, rawV) in raw_values:
        if len(rawD) == 0:
            rawD = rawV

        if rawV[0].isdigit():
            val = Decimal(rawV)
            string = str(rawD)

            if val.quantize(Decimal("1e-8"), rounding='ROUND_HALF_UP') != val:
                raise ValueError(f"Bad raw value: {rawV}")

            yield (string, val)
            continue

        if rawV == "Max":
            val = Decimal(2**64 - 1) / Decimal(10**8)
            string = "MaxUFix64"
            yield (string, val)
            continue

        if rawV == "HalfMax":
            val = Decimal(2**63 - 1) / Decimal(10**8)
            string = "HalfMaxUFix64"
            yield (string, val)
            continue

        m = re.match(r"^([MH][a-zA-Z0-9]+) ([+-]) (\S+)$", rawV)
        if m:
            key = m.group(1)
            op = m.group(2)
            mod = Decimal(m.group(3))
            if key == "Max":
                val = Decimal(2**64 - 1) / Decimal(10**8)
            elif key == "HalfMax":
                val = Decimal(2**63 - 1) / Decimal(10**8)
            else:
                raise ValueError(f"Unknown symbolic value: {key}")
            if op == "+":
                val += mod
            elif op == "-":
                val -= mod
            else:
                raise ValueError(f"Unknown operator: {op}")
            string = f"{key}UFix64 {op} {mod}"
        else:
            raise ValueError(f"Invalid raw value format: {rawV}")

        yield (string, val)

# Generates a sequence of Fix64 test values based on the provided raw values.
# Each test value is a tuple of (string representation, Decimal value).
@Pipe
def generateFix64Values(raw_values):
    for (rawD, rawV) in raw_values:
        if len(rawD) == 0:
            rawD = rawV

        if rawV == "0":
            val = Decimal("0")
            string = "0"
            yield (string, val)
            continue

        if rawV[0].isdigit():
            val = Decimal(rawV)
            string = str(rawD)

            yield (string, val)
            yield ("-" + string, -val)
            continue

        if rawV == "Max":
            val = Decimal(2**63 - 1) / Decimal(10**8)
            yield ("MaxFix64", val)
            val = -Decimal(2**63) / Decimal(10**8)
            yield ("MinFix64", val)
            continue

        if rawV == "HalfMax":
            val = Decimal(2**62 - 1) / Decimal(10**8)
            yield ("HalfMaxFix64", val)
            val = -Decimal(2**62) / Decimal(10**8)
            yield ("HalfMinFix64", val)
            continue

        m = re.match(r"^([MH][a-zA-Z0-9]+) ([+-]) (\S+)$", rawV)
        if m:
            key = m.group(1)
            op = m.group(2)
            mod = Decimal(m.group(3))
            if key == "Max":
                baseVal = Decimal(2**63 - 1) / Decimal(10**8)
            elif key == "HalfMax":
                baseVal = Decimal(2**62 - 1) / Decimal(10**8)
            else:
                raise ValueError(f"Unknown symbolic value: {key}")
            
            # First output the positive value
            if op == "+":
                val = baseVal + mod
            elif op == "-":
                val = baseVal - mod
            else:
                raise ValueError(f"Unknown operator: {op}")
            string = f"{key}Fix64 {op} {mod}"
            yield (string, val)

            # Now output the corresponding negative value
            key = key.replace("Max", "Min")
            if op == "+":
                op = "-"
            else:
                op = "+"

            # Negative min values are one larger than positive max values
            baseVal += Decimal('1e-8')

            if op == "+":
                val = baseVal + mod
            elif op == "-":
                val = baseVal - mod
            else:
                raise ValueError(f"Unknown operator: {op}")
            string = f"{key}Fix64 {op} {mod}"
            yield (string, val)
        else:
            raise ValueError(f"Invalid raw value format: {rawV}")

@Pipe
def expandByIota64(values):
    for val in values:
        yield val

        # Generate values ± 1e-8 around the original value
        newVal = val[1] + Decimal("1e-8")
        newStr = val[0] + " + 1e-8"

        if len(str(newVal)) < len(newStr):
            newStr = str(newVal).lower()

        yield (newStr, newVal)

        newVal = val[1] - Decimal("1e-8")
        newStr = val[0] + " - 1e-8"

        if len(str(newVal)) < len(newStr):
            newStr = str(newVal).lower()

        yield (newStr, newVal)

def isUFix64Value(val):
    """Check if the value is a valid UFix64 value."""
    if isinstance(val, Decimal):
        testVal = val.quantize(Decimal("1e-8"), rounding='ROUND_HALF_UP')
        return 0 <= testVal <= Decimal("184467440737.09551615") and \
                (testVal == 0 or testVal >= Decimal("1e-8"))
    return False

@Pipe
def filterUFix64Values(values):
    return (x for x in values if isUFix64Value(x[1]))

def isFix64Value(val):
    """Check if the value is a valid Fix64 value."""
    if isinstance(val, Decimal):
        testVal = val.quantize(Decimal("1e-8"), rounding='ROUND_HALF_UP')
        return Decimal("-92233720368.54775808") <= testVal <= Decimal("92233720368.54775807") and \
                (testVal == 0 or testVal.copy_sign(1) >= Decimal("1e-8"))
    return False

@Pipe
def filterFix64Values(values):
    return [x for x in values if isFix64Value(x[1])]
